# Review

## LoginController

1. Поле `roulette` не имеет явно заданного модификатора доступа и по умолчанию имеет package-private доступ. Как следствие, нарушается пирнцип инкапсуляции. \
**Решение**:  Для улучшения инкапсуляции класс  лучше указать модификатор `private` для `roulette` для предотвращения прямого доступа извне. И добавить геттеры. Или можно внедрить через конструктор (например, с использованием аннотации `@Autowired`).

## RouletteService

1. Поля `PAYOUT_RATE` и `ALL_BETS` больше относяться к правилам игры,а не к процессу. Это немного нарушает принцип разделения ответственности, потому что класс `RouletteService` отвечает за логику игры.\
**Решение**: Вынести поля `PAYOUT_RATE` и `ALL_BETS` в отдельный класс, например, `RouletteRules`, и уже его использовать в `RouletteService`.

## Bet

1. Поле `number` является единственным во всем классе, не помеченным модификатором `final`. Оно изменятся через сеттер `setNumber`. Сам класс `Bet` отвечает совершенную за ставку, и странно, что ставка может меняться после создания. Весь класс `Bet` очень похож на иммутабельный, однако иммутабельность нарушает изменяемое поле `number`. Это также может стать проблемой, если класс будет меняться в многопоточной среде. \
**Решение**: сделать класс `Bet` полностью иммутабельным и убрать сеттер `setNumber`. Значение для поля `number` передавать в контруктор, как и для всех остальных полей класса. Убрать сеттеры,
2. Поле `number` инициализированно магической константой. Непонятно, откуда она появляется и почему именно такая. \
**Решение**: убрать эту магическую константу `-1` и заменить ее на какую-то константу `DEFAULT_VALUE`.

## Result
1. Класс `Result` является мутабельным, поля `userId` и `payout` можно изменить при помщи сеттеров setUserId хотя желание изменить результат при помощи сеттеров странное. В добавок в остальных частях кода создаются экземпляры класса `Result`, которые дальше не меняются.\
**Решение**: Сделать класс `Result` иммутабельным. Добавить для полей модификаторы `final`. Убрать сеттеры. Оставить только конструктор, в котором задаются значения полей класса при создании.

2. Все поля `Result` являются приватными, и никто не может получить доступ к их значениям. Очень не хватает геттеров.\
**Решение**: Добавить геттеры `getUserId` и `getPayout`

3. Название для класса `Result` не очень говорящее. Непонятно, за какой результат отвечает этот класс.\
**Решение**: Изменить название класса на `BetResult` или `BettingResult`, например.

## Roulette
1. В классе `Roulette` нарушен принцип инкапсуляции: поля класса `users` и `bets` имеют модиикатор `package-private`. Все поля в классах должны быть private.\
**Решение**: Добавить модификатор доступа `private`, а вместе с ними и геттеры для получения значения всех полей.

2. К полям класса `users` и `bets` происходит обращение через `ArrayList`, что с точки зрения программирования через интерфейсы считается дурным тоном.
\
**Решение**: Обращатся к полям `Roulette` через интерфейс `List`, а в качестве конкретной реализации этого интерфейса взять `ArrayList`.

3. `Enum BET_TYPE` и списки `mul2Win` и `mul3Win` я бы вынесла в какой-то другой класс, потому что это больше правила игры в рулетку, а не сам процесс. \
**Решение**: Создать класс `RouletteRules`, в который можно поместить `enum`, `mul2Win` и `mul3Win`.

4. Поменять название `mul2Win` и `mul3Win`, потому что сейчас непонятно, что это вообще за списки.

## User

1. Поле `id` не имеет модификатора `final` и является изменяемым. Непонятно, зачем может потребоваться изменение `id` пользователя. Плюс на данный момент нет никакого сеттера и значение задается один раз в контрукторе. \
**Решение**: сделать поле `id` неизменяемым.

2. Поле `balance` при объявлении инициализируется магической константой в момент объявления.\
**Решение**: перенести инициализацию поля `balance` в контруктор и использовать для инициализации константу, например, `INITIAL_BALANCE`. Это позволит сделать код более понятным.


## Общие проблемы

1. Нехватка документации и комментариев в коде: невсегда понятно, за что отвечает тот или иной метод.
2. Неверно указанные модификаторы доступа у полей классов.
3. Наименование переменных, полей и методов.
4. Несоблюдение принципа разделения ответственности.
5. Иногда нарушается инкапсуляция.

## Что будет дальше?

Код имеет хорошую основу для дальнейшей работы. Исправив все недочеты, указанные выше, можно превратить его в "чистый код", который будет легко поддерживаем в будущем и будет соотвествовать всем принципам ООП.
